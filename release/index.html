<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PointMarker - ポイント図マーキング</title>
    <meta name="description" content="PNG画像のハイキングマップから視覚的にポイントを選択し、座標データをJSONファイルとして出力するWebアプリケーション">
    <style>
/* =====================================
   CSS Variables & Reset
   ===================================== */
:root {
    --sidebar-width: 240px;
    --primary-color: #3498db;
    --primary-dark: #2980b9;
    --secondary-color: #2c3e50;
    --success-color: #27ae60;
    --success-dark: #229954;
    --danger-color: #e74c3c;
    --danger-dark: #c0392b;
    --warning-color: #f39c12;
    --warning-dark: #d68910;
    --info-color: #17a2b8;
    --info-dark: #138496;
    --light-gray: #f8f9fa;
    --border-color: #e9ecef;
    --text-muted: #7f8c8d;
    --box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    --box-shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.15);
    --border-radius: 6px;
    --border-radius-sm: 4px;
    --transition: all 0.3s ease;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* =====================================
   Base Styles
   ===================================== */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.5;
    font-size: 13px;
    overflow-x: hidden;
}

/* Screen reader only content */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* =====================================
   Layout Structure
   ===================================== */
.container {
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

header {
    text-align: center;
    padding: 10px 20px;
    background: white;
    box-shadow: var(--box-shadow);
    z-index: 100;
}

header h1 {
    color: var(--secondary-color);
    font-size: 1.5em;
    margin-bottom: 5px;
}

header p {
    color: var(--text-muted);
    font-size: 0.8em;
}

.main-content {
    display: flex;
    flex: 1;
    min-height: 0;
    position: relative;
}

.main-content[data-layout="sidebar"] {
    flex-direction: row;
}

.main-content[data-layout="overlay"] {
    flex-direction: column;
}

/* =====================================
   Map Container
   ===================================== */
.map-container {
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
}

[data-layout="sidebar"] .map-container {
    flex: 1;
    width: calc(100vw - var(--sidebar-width));
    height: 100%;
}

[data-layout="overlay"] .map-container {
    width: 100vw;
    height: 100%;
    flex: 1;
}

.map-canvas {
    border: 2px solid #ddd;
    cursor: crosshair;
    object-fit: contain;
    transition: border-color 0.2s ease;
}

.map-canvas:hover {
    border-color: var(--primary-color);
}

[data-layout="sidebar"] .map-canvas {
    max-width: calc(100vw - var(--sidebar-width) - 40px);
    max-height: calc(100vh - 140px);
}

[data-layout="overlay"] .map-canvas {
    max-width: calc(100vw - 40px);
    max-height: calc(100vh - 140px);
}

/* =====================================
   Controls Sidebar
   ===================================== */
.controls-sidebar {
    display: flex;
    flex-direction: column;
    gap: 15px;
    background: white;
    padding: 20px;
    box-shadow: var(--box-shadow);
    transition: var(--transition);
    overflow-y: auto;
}

[data-layout="sidebar"] .controls-sidebar {
    width: var(--sidebar-width);
    height: 100%;
    position: relative;
}

[data-layout="overlay"] .controls-sidebar {
    position: fixed;
    top: 110px;
    right: 20px;
    width: var(--sidebar-width);
    max-height: calc(100vh - 150px);
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    z-index: 1000;
    box-shadow: var(--box-shadow-lg);
}

/* =====================================
   Layout Selector
   ===================================== */
.layout-selector {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 2000;
    display: flex;
    gap: 10px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 8px 12px;
    box-shadow: var(--box-shadow);
}

.layout-option {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    font-size: 12px;
    color: #666;
    transition: color 0.3s ease;
}

.layout-option input[type="radio"] {
    margin: 0;
    transform: scale(0.8);
}

.layout-option:has(input:checked) {
    color: var(--primary-color);
    font-weight: 500;
}

.layout-option:hover {
    color: var(--primary-dark);
}

/* =====================================
   Form Elements
   ===================================== */
.file-input-wrapper {
    position: relative;
}

.file-input {
    position: absolute;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
    z-index: -1;
}

.file-input-label {
    display: block;
    padding: 10px 16px;
    background: var(--primary-color);
    color: white;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: background-color 0.3s ease;
    font-weight: 500;
    text-align: center;
    width: 100%;
    font-size: 13px;
}

.file-input-label:hover {
    background: var(--primary-dark);
}

/* =====================================
   Buttons
   ===================================== */
.btn {
    padding: 10px 16px;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: var(--transition);
    text-align: center;
    display: inline-block;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.btn-clear {
    background: var(--danger-color);
    color: white;
}

.btn-clear:hover:not(:disabled) {
    background: var(--danger-dark);
}

.btn-format {
    background: var(--warning-color);
    color: white;
}

.btn-format:hover:not(:disabled) {
    background: var(--warning-dark);
}

.btn-export {
    background: var(--success-color);
    color: white;
}

.btn-export:hover:not(:disabled) {
    background: var(--success-dark);
}

.btn-export-route {
    background: var(--success-color);
    color: white;
}

.btn-export-route:hover:not(:disabled) {
    background: var(--success-dark);
}

.btn-clear-route {
    background: var(--danger-color);
    color: white;
}

.btn-clear-route:hover:not(:disabled) {
    background: var(--danger-dark);
}

/* スポット編集ボタンの色分け */
.btn-clear-spot {
    background: var(--danger-color);  /* 赤色 */
    color: white;
}

.btn-clear-spot:hover:not(:disabled) {
    background: var(--danger-dark);
}

.btn-export-spot {
    background: var(--success-color);  /* 緑色 */
    color: white;
}

.btn-export-spot:hover:not(:disabled) {
    background: var(--success-dark);
}

.btn-load-spot {
    background: var(--primary-color);  /* 青色 */
    color: white;
}

.btn-load-spot:hover:not(:disabled) {
    background: var(--primary-dark);
}

/* =====================================
   Editing Mode Selector
   ===================================== */
.editing-mode-selector {
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    padding: 12px;
    background: var(--light-gray);
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.editing-option {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    font-size: 13px;
    color: #666;
    transition: color 0.3s ease;
}

.editing-option input[type="radio"] {
    margin: 0;
    transform: scale(0.9);
}

.editing-option:has(input:checked) {
    color: var(--primary-color);
    font-weight: 500;
}

.editing-option:hover {
    color: var(--primary-dark);
}

/* =====================================
   Editor Panels
   ===================================== */
.point-editor,
.route-editor,
.spot-editor {
    padding: 15px;
    background: var(--light-gray);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.point-editor h3,
.route-editor h3,
.spot-editor h3 {
    margin: 0;
    color: var(--secondary-color);
    font-size: 1.1em;
}

.editor-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* =====================================
   Route Controls
   ===================================== */
.route-info {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.route-points-inputs {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 10px;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-sm);
}

.route-point-input {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 8px;
    flex-wrap: nowrap;
}

.route-point-input label {
    font-size: 12px;
    font-weight: 500;
    color: #495057;
    min-width: 80px;
    white-space: nowrap;
}

.route-point-field {
    width: 60px;
    padding: 6px 8px;
    border: 2px solid var(--border-color);
    border-radius: var(--border-radius-sm);
    font-size: 12px;
    font-weight: bold;
    text-align: center;
    outline: none;
    transition: border-color 0.3s ease;
}

.route-point-field:focus {
    border-color: var(--primary-color);
}

.route-point-field::placeholder {
    color: #bdc3c7;
    font-weight: normal;
}

.route-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* =====================================
   Counters & Status
   ===================================== */
.point-count,
.waypoint-count,
.spot-count {
    padding: 10px;
    background: var(--light-gray);
    border-radius: var(--border-radius-sm);
    border: 1px solid var(--border-color);
    font-size: 1em;
    font-weight: 500;
    color: var(--secondary-color);
}

.point-count span {
    color: var(--primary-color);
    font-weight: bold;
}

.waypoint-count {
    font-size: 0.9em;
    background: white;
}

.waypoint-count span {
    color: #e67e22;
    font-weight: bold;
}

.spot-count span {
    color: #ff9500;
    font-weight: bold;
}

/* =====================================
   Point ID Inputs (Dynamic)
   ===================================== */
.point-id-input {
    width: 50px;
    height: 24px;
    padding: 2px 6px;
    border: none;
    border-radius: var(--border-radius-sm);
    background: transparent;
    font-size: 12px;
    font-weight: bold;
    text-align: center;
    outline: none;
    transition: var(--transition);
}

/* ポップアップコンテナ（入力＋プレビュー） */
.point-id-popup {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    padding: 1px 2px;
    background: white;
    border: 2px solid var(--primary-color);
    border-radius: 4px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    pointer-events: auto;
}

.point-id-popup.is-editing {
    border-color: var(--primary-dark);
    box-shadow: 0 2px 4px rgba(52, 152, 219, 0.5);
}

/* 入力中の文字プレビュー（削除） */

/* .point-id-input:focus のスタイルは .point-id-popup.is-editing で処理 */

.point-id-input::placeholder {
    color: #bdc3c7;
    font-size: 10px;
}

/* スポット名入力ポップアップ */
.spot-name-popup {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    padding: 1px 2px;
    background: white;
    border: 2px solid #ff9500;  /* オレンジ色の枠線 */
    border-radius: 4px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    pointer-events: auto;
}

.spot-name-popup.is-editing {
    border-color: #e67e00;  /* 濃いオレンジ色 */
    box-shadow: 0 2px 4px rgba(255, 149, 0, 0.5);
}

.spot-name-input {
    width: 80px;
    height: 24px;
    padding: 2px 6px;
    border: none;
    border-radius: var(--border-radius-sm);
    background: transparent;
    font-size: 11px;
    font-weight: normal;
    text-align: left;
    outline: none;
    overflow: hidden;
    white-space: nowrap;
}

.spot-name-input::placeholder {
    color: #bdc3c7;
    font-size: 10px;
}

/* =====================================
   Responsive Design
   ===================================== */
@media (max-width: 768px) {
    .container {
        padding: 0;
    }
    
    header h1 {
        font-size: 1.3em;
    }
    
    header p {
        font-size: 0.7em;
    }
    
    .main-content[data-layout="sidebar"] {
        flex-direction: column;
    }
    
    [data-layout="sidebar"] .controls-sidebar {
        width: 100%;
        height: auto;
        max-height: 200px;
        order: -1;
    }
    
    [data-layout="sidebar"] .map-container {
        width: 100vw;
        flex: 1;
    }
    
    [data-layout="sidebar"] .map-canvas {
        max-width: calc(100vw - 40px);
        max-height: calc(100vh - 280px);
    }
    
    [data-layout="overlay"] .controls-sidebar {
        width: var(--sidebar-width);
        right: 10px;
        top: 100px;
    }
    
    .point-id-input {
        width: 45px;
        height: 22px;
        font-size: 11px;
    }
    
    .layout-selector {
        top: 15px;
        right: 15px;
        padding: 6px 10px;
    }
    
    .layout-option {
        font-size: 11px;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <!-- レイアウト選択 -->
        <div class="layout-selector">
            <label class="layout-option">
                <input type="radio" name="layout" value="sidebar" checked>
                <span>サイドバー</span>
            </label>
            <label class="layout-option">
                <input type="radio" name="layout" value="overlay">
                <span>オーバーレイ</span>
            </label>
        </div>

        <!-- ヘッダー -->
        <header>
            <h1>Points/Spots and Routes Marker</h1>
            <p>ハイキングマップからポイント・スポットやルートをマークしてJSON出力</p>
        </header>
        
        <!-- メインコンテンツ -->
        <main class="main-content" data-layout="sidebar">
            <!-- 地図表示エリア -->
            <div class="map-container">
                <canvas id="mapCanvas" class="map-canvas"></canvas>
            </div>
            
            <!-- コントロールサイドバー -->
            <aside class="controls-sidebar">
                <!-- 画像ファイル入力 -->
                <div class="file-input-wrapper">
                    <input type="file" id="imageInput" accept="image/png" class="file-input" aria-label="PNG画像を選択">
                    <label for="imageInput" class="file-input-label">
                        PNG画像を選択
                    </label>
                </div>
                
                <!-- 編集モード選択 -->
                <fieldset class="editing-mode-selector">
                    <legend class="sr-only">編集モード選択</legend>
                    <label class="editing-option">
                        <input type="radio" name="editingMode" value="point" checked>
                        <span>ポイント編集</span>
                    </label>
                    <label class="editing-option">
                        <input type="radio" name="editingMode" value="route">
                        <span>ルート編集</span>
                    </label>
                    <label class="editing-option">
                        <input type="radio" name="editingMode" value="spot">
                        <span>スポット編集</span>
                    </label>
                </fieldset>
                
                <!-- ポイント編集パネル -->
                <section class="point-editor" id="pointEditor">
                    <h3>ポイント編集</h3>
                    
                    <div class="editor-controls">
                        <button type="button" id="clearBtn" class="btn btn-clear" disabled aria-label="全ポイントをクリア">
                            ポイントをクリア
                        </button>
                        <button type="button" id="formatBtn" class="btn btn-format" disabled aria-label="全ポイントID名を補正">
                            ポイントID名の補正
                        </button>
                        <button type="button" id="exportBtn" class="btn btn-export" disabled aria-label="ポイントをJSONで出力">
                            ポイントをJSON出力
                        </button>
                    </div>
                    
                    <div class="file-input-wrapper">
                        <input type="file" id="jsonInput" accept="application/json" class="file-input" aria-label="ポイントJSONファイルを読み込み">
                        <label for="jsonInput" class="file-input-label">
                            ポイントのJSON読込
                        </label>
                    </div>
                    
                    <div class="point-count" aria-live="polite">
                        ポイント数: <span id="pointCount">0</span>
                    </div>
                </section>
                
                <!-- ルート編集パネル -->
                <section class="route-editor" id="routeEditor" style="display: none;">
                    <h3>ルート編集</h3>
                    
                    <div class="route-info">
                        <!-- 開始・終了ポイント設定 -->
                        <div class="route-points-inputs">
                            <div class="route-point-input">
                                <label for="startPointInput">開始ポイント:</label>
                                <input type="text" id="startPointInput" class="route-point-field" maxlength="4" aria-describedby="start-point-desc">
                                <span id="start-point-desc" class="sr-only">既存ポイントのIDを入力</span>
                            </div>
                            <div class="route-point-input">
                                <label for="endPointInput">終了ポイント:</label>
                                <input type="text" id="endPointInput" class="route-point-field" maxlength="4" aria-describedby="end-point-desc">
                                <span id="end-point-desc" class="sr-only">既存ポイントのIDを入力</span>
                            </div>
                            
                            <!-- 中間点数表示 -->
                            <div class="waypoint-count" aria-live="polite">
                                中間点数: <span id="waypointCount">0</span>
                            </div>
                        </div>
                        
                        <!-- ルート制御ボタン -->
                        <div class="route-controls">
                            <button type="button" id="clearRouteBtn" class="btn btn-clear-route" aria-label="ルート中間点をクリア">
                                ルートをクリア
                            </button>
                            <button type="button" id="exportRouteBtn" class="btn btn-export-route" aria-label="ルートをJSONで出力">
                                ルートをJSON出力
                            </button>
                        </div>
                        
                        <!-- ルートJSON読込 -->
                        <div class="file-input-wrapper">
                            <input type="file" id="routeJsonInput" accept="application/json" class="file-input" aria-label="ルートJSONファイルを読み込み">
                            <label for="routeJsonInput" class="file-input-label">
                                ルートのJSON読込
                            </label>
                        </div>
                    </div>
                </section>
                
                <!-- スポット編集パネル -->
                <section class="spot-editor" id="spotEditor" style="display: none;">
                    <h3>スポット編集</h3>
                    
                    <div class="editor-controls">
                        <button type="button" id="clearSpotBtn" class="btn btn-clear" aria-label="全スポットをクリア">
                            スポットをクリア
                        </button>
                        <button type="button" id="exportSpotBtn" class="btn btn-export" aria-label="スポットをJSONで出力">
                            スポットをJSON出力
                        </button>
                    </div>
                    
                    <div class="file-input-wrapper">
                        <input type="file" id="spotJsonInput" accept="application/json" class="file-input" aria-label="スポットJSONファイルを読み込み">
                        <label for="spotJsonInput" class="file-input-label">
                            スポットのJSON読込
                        </label>
                    </div>
                    
                    <div class="spot-count" aria-live="polite">
                        スポット数: <span id="spotCount">0</span>
                    </div>
                </section>
            </aside>
        </main>
    </div>
    
    <script>
// =====================================
// CoordinateUtils
// =====================================
class CoordinateUtils {
    static canvasToImage(canvasX, canvasY, canvasWidth, canvasHeight, imageWidth, imageHeight) {
        const scaleX = imageWidth / canvasWidth;
        const scaleY = imageHeight / canvasHeight;
        return {
            x: Math.round(canvasX * scaleX),
            y: Math.round(canvasY * scaleY)
        };
    }

    static imageToCanvas(imageX, imageY, canvasWidth, canvasHeight, imageWidth, imageHeight) {
        const scaleX = canvasWidth / imageWidth;
        const scaleY = canvasHeight / imageHeight;
        return {
            x: Math.round(imageX * scaleX),
            y: Math.round(imageY * scaleY)
        };
    }

    static mouseToCanvas(event, canvas) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (event.clientX - rect.left) * (canvas.width / rect.width),
            y: (event.clientY - rect.top) * (canvas.height / rect.height)
        };
    }

    static canvasToScreen(canvasX, canvasY, canvas) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / canvas.width;
        const scaleY = rect.height / canvas.height;
        return {
            x: canvasX * scaleX + rect.left,
            y: canvasY * scaleY + rect.top
        };
    }
}

// =====================================
// Validators
// =====================================
class Validators {
    static isValidPointIdFormat(value) {
        if (!value || value.trim() === '') {
            return true;
        }
        
        const validPattern = /^[A-Z]-\d{2}$/;
        return validPattern.test(value);
    }

    static formatPointId(value) {
        if (!value || value.trim() === '') {
            return value;
        }
        
        // 1. 全角英数字を半角英数字に変換
        let convertedValue = this.convertFullWidthToHalfWidth(value);
        
        // 2. 英小文字を英大文字に変換
        convertedValue = convertedValue.toUpperCase();
        
        // 完全な「X-nn」形式（2桁数字）の場合
        const fullMatch = convertedValue.match(/^([A-Z])[-]?(\d{2})$/);
        if (fullMatch) {
            const letter = fullMatch[1];
            const numbers = fullMatch[2];
            return `${letter}-${numbers}`;
        }
        
        // 不完全な入力「X-n」（1桁数字）の場合
        const partialMatch = convertedValue.match(/^([A-Z])[-]?(\d{1})$/);
        if (partialMatch) {
            const letter = partialMatch[1];
            const number = partialMatch[2];
            // 1桁の場合は0埋めしてフォーマット
            return `${letter}-${number.padStart(2, '0')}`;
        }
        
        // ハイフンなしの「X数字」形式の場合
        const noHyphenMatch = convertedValue.match(/^([A-Z])(\d{1,2})$/);
        if (noHyphenMatch) {
            const letter = noHyphenMatch[1];
            const numbers = noHyphenMatch[2].padStart(2, '0');
            return `${letter}-${numbers}`;
        }
        
        // 数字のみの場合は変換しない
        if (convertedValue.match(/^\d+$/)) {
            return convertedValue;
        }
        
        return convertedValue;
    }
    
    static convertFullWidthToHalfWidth(str) {
        return str.replace(/[Ａ-Ｚａ-ｚ０-９－−‐―]/g, function(char) {
            if (char >= 'Ａ' && char <= 'Ｚ') {
                return String.fromCharCode(char.charCodeAt(0) - 0xFEE0);
            }
            if (char >= 'ａ' && char <= 'ｚ') {
                // 全角小文字を半角小文字に変換（大文字変換は後で行う）
                return String.fromCharCode(char.charCodeAt(0) - 0xFEE0);
            }
            if (char >= '０' && char <= '９') {
                return String.fromCharCode(char.charCodeAt(0) - 0xFEE0);
            }
            if (char === '－' || char === '−' || char === '‐' || char === '―') {
                return '-';
            }
            return char;
        });
    }

    static isPngFile(file) {
        return file && file.type.includes('png');
    }

    static isJsonFile(file) {
        return file && file.type.includes('json');
    }

    static isValidPointData(data) {
        return data && data.points && Array.isArray(data.points);
    }

    static isValidRouteData(data) {
        return data && data.points && Array.isArray(data.points) && data.routeInfo;
    }

    static isValidSpotData(data) {
        return data && data.points && Array.isArray(data.points) && 
               data.points.some(point => point.type === 'spot');
    }
}

// =====================================
// CanvasRenderer
// =====================================
class CanvasRenderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.currentImage = null;
    }

    setImage(image) {
        this.currentImage = image;
    }

    drawImage() {
        if (!this.currentImage) return;
        
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(this.currentImage, 0, 0, this.canvas.width, this.canvas.height);
    }

    drawPoint(point, color = '#ff0000', radius = 4, strokeWidth = 1.5) {
        this.ctx.fillStyle = color;
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = strokeWidth;
        
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
        this.ctx.fill();
        this.ctx.stroke();
    }

    drawPoints(points, options = {}) {
        const {
            defaultColor = '#ff0000',
            highlightColor = '#0066ff',
            startPointId = '',
            endPointId = '',
            showRouteMode = false
        } = options;

        points.forEach((point) => {
            let color = defaultColor;
            let radius = 4;
            let strokeWidth = 1.5;
            
            if ((showRouteMode || startPointId || endPointId) && 
                (point.id === startPointId || point.id === endPointId)) {
                color = highlightColor;
            }
            
            this.drawPoint(point, color, radius, strokeWidth);
        });
    }

    drawRoutePoints(routePoints) {
        routePoints.forEach(point => {
            this.drawPoint(point, '#0066ff', 3, 1);
        });
    }

    drawStar(cx, cy, spikes = 5, outerRadius = 8, innerRadius = 4, fillColor = '#ffcc00', strokeColor = '#ffffff', strokeWidth = 1.5) {
        let rot = Math.PI / 2 * 3;
        let x, y;
        const step = Math.PI / spikes;
        
        this.ctx.beginPath();
        this.ctx.moveTo(cx, cy - outerRadius);
        
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            this.ctx.lineTo(x, y);
            rot += step;
            
            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            this.ctx.lineTo(x, y);
            rot += step;
        }
        
        this.ctx.lineTo(cx, cy - outerRadius);
        this.ctx.closePath();
        
        this.ctx.fillStyle = fillColor;
        this.ctx.fill();
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = strokeWidth;
        this.ctx.stroke();
    }

    drawSquare(cx, cy, size, fillColor = '#ff9500', strokeColor = '#ffffff', strokeWidth = 1) {
        const halfSize = size / 2;
        
        this.ctx.fillStyle = fillColor;
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = strokeWidth;
        
        this.ctx.fillRect(cx - halfSize, cy - halfSize, size, size);
        this.ctx.strokeRect(cx - halfSize, cy - halfSize, size, size);
    }

    drawSpots(spots, options = {}) {
        const {
            fillColor = '#ff9500',    // オレンジ色
            strokeColor = '#ffffff',   // 白色の枠線
            size = 12,                 // 6px 半径 = 12px 一辺
            strokeWidth = 1
        } = options;

        spots.forEach(spot => {
            this.drawSquare(spot.x, spot.y, size, fillColor, strokeColor, strokeWidth);
        });
    }

    redraw(points = [], routePoints = [], spots = [], options = {}) {
        this.drawImage();
        this.drawPoints(points, options);
        this.drawRoutePoints(routePoints);
        this.drawSpots(spots, options);
    }

    setupCanvas(layout = 'sidebar') {
        if (!this.currentImage) return;
        
        const container = this.canvas.parentElement;
        const containerRect = container.getBoundingClientRect();
        
        let availableWidth, availableHeight;
        
        if (layout === 'sidebar') {
            availableWidth = containerRect.width - 40;
            availableHeight = window.innerHeight - 140;
        } else {
            availableWidth = window.innerWidth - 40;
            availableHeight = window.innerHeight - 140;
        }
        
        const imageAspectRatio = this.currentImage.height / this.currentImage.width;
        
        let canvasWidth = availableWidth;
        let canvasHeight = canvasWidth * imageAspectRatio;
        
        if (canvasHeight > availableHeight) {
            canvasHeight = availableHeight;
            canvasWidth = canvasHeight / imageAspectRatio;
        }
        
        this.canvas.width = canvasWidth;
        this.canvas.height = canvasHeight;
        this.canvas.style.width = canvasWidth + 'px';
        this.canvas.style.height = canvasHeight + 'px';
        this.canvas.style.display = 'block';
        this.canvas.style.visibility = 'visible';
    }
}

// =====================================
// PointManager
// =====================================
class PointManager {
    constructor() {
        this.points = [];
        this.callbacks = {
            onChange: null,
            onCountChange: null
        };
    }

    setCallback(event, callback) {
        this.callbacks[event] = callback;
    }

    notify(event, data, ...args) {
        if (this.callbacks[event]) {
            this.callbacks[event](data, ...args);
        }
    }

    addPoint(x, y, id = '') {
        const point = { 
            x: Math.round(x), 
            y: Math.round(y),
            id
        };
        
        this.points.push(point);
        this.notify('onChange', this.points);
        this.notify('onCountChange', this.getUserPointCount());
        return point;
    }

    removePoint(index) {
        if (index >= 0 && index < this.points.length) {
            this.points.splice(index, 1);
            this.notify('onChange', this.points);
            this.notify('onCountChange', this.getUserPointCount());
        }
    }

    updatePointId(index, newId, skipFormatting = false, skipRedrawInput = false) {
        if (index >= 0 && index < this.points.length) {
            this.points[index].id = skipFormatting ? newId : Validators.formatPointId(newId);
            // skipRedrawInputがtrueの場合はonChange通知を送らない（入力中のフォーカス保持のため）
            if (!skipRedrawInput) {
                this.notify('onChange', this.points, skipRedrawInput);
            }
        }
    }

    clearPoints() {
        this.points = [];
        this.notify('onChange', this.points);
        this.notify('onCountChange', 0);
    }

    formatAllPointIds() {
        // まず、ID名のフォーマット補正を実行
        this.points.forEach(point => {
            if (point.id) {
                point.id = Validators.formatPointId(point.id);
            }
        });
        
        // 次に、ID名がブランクまたは空のポイントを削除
        const initialLength = this.points.length;
        this.points = this.points.filter(point => {
            return point.id && point.id.trim() !== '';
        });
        
        // ポイント数が変更された場合は数の更新通知も送信
        if (this.points.length !== initialLength) {
            this.notify('onCountChange', this.getUserPointCount());
        }
        
        this.notify('onChange', this.points);
    }

    getPoints() {
        return this.points;
    }

    getUserPointCount() {
        return this.points.length;
    }

    findPointById(id) {
        return this.points.find(point => point.id === id) || null;
    }

    getRegisteredIds() {
        return this.points
            .map(point => point.id)
            .filter(id => id.trim() !== '');
    }

    removeTrailingEmptyUserPoints() {
        if (this.points.length === 0) return;
        
        let removed = false;
        for (let i = this.points.length - 1; i >= 0; i--) {
            const point = this.points[i];
            if ((point.id ?? '') === '') {
                this.points.splice(i, 1);
                removed = true;
            } else {
                break;
            }
        }
        
        if (removed) {
            this.notify('onChange', this.points);
            this.notify('onCountChange', this.getUserPointCount());
        }
    }

    loadFromJSON(data, canvasWidth, canvasHeight, imageWidth, imageHeight) {
        if (!Validators.isValidPointData(data)) {
            throw new Error('JSONファイルにポイントデータが見つかりません');
        }

        this.points = [];
        
        data.points.forEach(pointData => {
            if (pointData.imageX !== undefined && pointData.imageY !== undefined) {
                const canvasCoords = CoordinateUtils.imageToCanvas(
                    pointData.imageX, pointData.imageY,
                    canvasWidth, canvasHeight,
                    imageWidth, imageHeight
                );
                
                this.addPoint(
                    canvasCoords.x, canvasCoords.y,
                    pointData.id || ''
                );
            }
        });
        
        this.notify('onChange', this.points);
        this.notify('onCountChange', this.getUserPointCount());
    }

    exportToJSON(imageFileName, canvasWidth, canvasHeight, imageWidth, imageHeight) {
        return {
            totalPoints: this.points.length,
            imageReference: imageFileName,
            imageInfo: {
                width: imageWidth,
                height: imageHeight
            },
            points: this.points.map((point, index) => {
                const imageCoords = CoordinateUtils.canvasToImage(
                    point.x, point.y,
                    canvasWidth, canvasHeight,
                    imageWidth, imageHeight
                );
                
                return {
                    index: index + 1,
                    id: point.id || '',
                    imageX: imageCoords.x,
                    imageY: imageCoords.y
                };
            }),
            exportedAt: new Date().toISOString()
        };
    }
}

// =====================================
// RouteManager
// =====================================
class RouteManager {
    constructor() {
        this.routePoints = [];
        this.startPointId = '';
        this.endPointId = '';
        this.callbacks = {
            onChange: null,
            onCountChange: null,
            onStartEndChange: null
        };
    }

    setCallback(event, callback) {
        this.callbacks[event] = callback;
    }

    notify(event, data) {
        if (this.callbacks[event]) {
            this.callbacks[event](data);
        }
    }

    addRoutePoint(x, y) {
        const point = { 
            x: Math.round(x), 
            y: Math.round(y)
        };
        
        this.routePoints.push(point);
        this.notify('onChange', this.routePoints);
        this.notify('onCountChange', this.routePoints.length);
        return point;
    }

    clearRoute() {
        this.routePoints = [];
        this.startPointId = '';
        this.endPointId = '';
        this.notify('onChange', this.routePoints);
        this.notify('onCountChange', 0);
        this.notify('onStartEndChange', { start: '', end: '' });
    }

    setStartPoint(id, skipFormatting = false) {
        this.startPointId = skipFormatting ? id : Validators.formatPointId(id);
        this.notify('onStartEndChange', { 
            start: this.startPointId, 
            end: this.endPointId 
        });
    }

    setEndPoint(id, skipFormatting = false) {
        this.endPointId = skipFormatting ? id : Validators.formatPointId(id);
        this.notify('onStartEndChange', { 
            start: this.startPointId, 
            end: this.endPointId 
        });
    }

    getRoutePoints() {
        return this.routePoints;
    }

    getStartEndPoints() {
        return {
            start: this.startPointId,
            end: this.endPointId
        };
    }

    validateStartEndPoints(registeredIds) {
        if (this.startPointId && !registeredIds.includes(this.startPointId)) {
            return {
                isValid: false,
                message: `開始ポイント "${this.startPointId}" がポイントとして登録されていません。先にポイント編集モードでポイントを登録してください。`
            };
        }
        
        if (this.endPointId && !registeredIds.includes(this.endPointId)) {
            return {
                isValid: false,
                message: `終了ポイント "${this.endPointId}" がポイントとして登録されていません。先にポイント編集モードでポイントを登録してください。`
            };
        }
        
        if (!this.startPointId || !this.endPointId) {
            return {
                isValid: false,
                message: '開始ポイントと終了ポイントの両方を設定してください。'
            };
        }
        
        // 中間点が1つ以上あることをチェック
        if (this.routePoints.length < 1) {
            return {
                isValid: false,
                message: 'ルートを作成するには中間点が1つ以上必要です。地図上をクリックして中間点を追加してください。'
            };
        }
        
        return { isValid: true };
    }

    generateRouteFilename(imageFileName) {
        const baseFileName = imageFileName || 'route';
        const startPoint = this.startPointId || 'start';
        const endPoint = this.endPointId || 'end';
        return `${baseFileName}_route_${startPoint}_to_${endPoint}.json`;
    }

    loadFromJSON(data, canvasWidth, canvasHeight, imageWidth, imageHeight) {
        if (!Validators.isValidRouteData(data)) {
            throw new Error('ルートJSONファイルの形式が正しくありません');
        }

        this.routePoints = [];
        this.startPointId = data.routeInfo.startPoint || '';
        this.endPointId = data.routeInfo.endPoint || '';
        
        data.points.forEach(pointData => {
            if (pointData.type === 'waypoint' && 
                pointData.imageX !== undefined && 
                pointData.imageY !== undefined) {
                const canvasCoords = CoordinateUtils.imageToCanvas(
                    pointData.imageX, pointData.imageY,
                    canvasWidth, canvasHeight,
                    imageWidth, imageHeight
                );
                
                this.routePoints.push({
                    x: canvasCoords.x,
                    y: canvasCoords.y
                });
            }
        });
        
        this.notify('onChange', this.routePoints);
        this.notify('onCountChange', this.routePoints.length);
        this.notify('onStartEndChange', { 
            start: this.startPointId, 
            end: this.endPointId 
        });
    }

    exportToJSON(imageFileName, canvasWidth, canvasHeight, imageWidth, imageHeight) {
        return {
            routeInfo: {
                startPoint: this.startPointId || '',
                endPoint: this.endPointId || '',
                waypointCount: this.routePoints.length
            },
            imageReference: imageFileName,
            imageInfo: {
                width: imageWidth,
                height: imageHeight
            },
            points: this.routePoints.map((point, index) => {
                const imageCoords = CoordinateUtils.canvasToImage(
                    point.x, point.y,
                    canvasWidth, canvasHeight,
                    imageWidth, imageHeight
                );
                
                return {
                    type: 'waypoint',
                    index: index + 1,
                    imageX: imageCoords.x,
                    imageY: imageCoords.y
                };
            }),
            exportedAt: new Date().toISOString()
        };
    }
}

// =====================================
// SpotManager
// =====================================
class SpotManager {
    constructor() {
        this.spots = [];
        this.callbacks = {};
    }

    setCallback(event, callback) {
        this.callbacks[event] = callback;
    }

    notify(event, data) {
        if (this.callbacks[event]) {
            this.callbacks[event](data);
        }
    }

    addSpot(x, y, name = '') {
        const spot = {
            x: Math.round(x),
            y: Math.round(y),
            name: name,
            index: this.spots.length
        };
        
        this.spots.push(spot);
        this.notify('onChange');
        this.notify('onCountChange', this.spots.length);
        
        return spot;
    }

    removeSpot(index) {
        if (index >= 0 && index < this.spots.length) {
            this.spots.splice(index, 1);
            // インデックスを再割り当て
            this.spots.forEach((spot, i) => {
                spot.index = i;
            });
            
            this.notify('onChange');
            this.notify('onCountChange', this.spots.length);
        }
    }

    clearSpots() {
        this.spots = [];
        this.notify('onChange');
        this.notify('onCountChange', 0);
    }

    getSpots() {
        return this.spots;
    }

    getSpotCount() {
        return this.spots.length;
    }

    findSpotAt(x, y, tolerance = 8) {
        for (let i = 0; i < this.spots.length; i++) {
            const spot = this.spots[i];
            const dx = x - spot.x;
            const dy = y - spot.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= tolerance) {
                return i;
            }
        }
        return -1;
    }

    updateSpotPosition(index, x, y) {
        if (index >= 0 && index < this.spots.length) {
            this.spots[index].x = Math.round(x);
            this.spots[index].y = Math.round(y);
            this.notify('onChange');
        }
    }

    updateSpotName(index, name, skipRedrawInput = false) {
        if (index >= 0 && index < this.spots.length) {
            // スポット名がブランクの場合はスポットを削除
            if (!name || name.trim() === '') {
                if (!skipRedrawInput) {
                    // フォーカス離脱時（blur）でブランクの場合は削除
                    this.removeSpot(index);
                    return;
                }
            }
            
            this.spots[index].name = name;
            // 入力中は入力ボックスの再生成を避けるため
            if (skipRedrawInput) {
                // 入力中はキャンバス再描画のみ（入力ボックス再生成はスキップ）
                this.redrawCanvasOnly();
            } else {
                // 通常の変更時は全て再描画
                this.notify('onChange', this.spots, false);
            }
        }
    }

    redrawCanvasOnly() {
        // 直接キャンバス再描画のみを実行
        if (this.callbacks.onCanvasRedraw) {
            this.callbacks.onCanvasRedraw();
        }
    }

    removeTrailingEmptySpots() {
        if (this.spots.length === 0) return;
        
        let removed = false;
        for (let i = this.spots.length - 1; i >= 0; i--) {
            const spot = this.spots[i];
            if ((spot.name ?? '') === '') {
                this.spots.splice(i, 1);
                removed = true;
            } else {
                break;
            }
        }
        
        if (removed) {
            // インデックスを再割り当て
            this.spots.forEach((spot, i) => {
                spot.index = i;
            });
            this.notify('onChange');
            this.notify('onCountChange', this.spots.length);
        }
    }

    loadFromJSON(data, canvasWidth, canvasHeight, imageWidth, imageHeight) {
        if (!Validators.isValidSpotData(data)) {
            throw new Error('JSONファイルにスポットデータが見つかりません');
        }

        this.spots = [];
        
        data.points.forEach(pointData => {
            if (pointData.type === 'spot' && 
                pointData.imageX !== undefined && 
                pointData.imageY !== undefined) {
                const canvasCoords = CoordinateUtils.imageToCanvas(
                    pointData.imageX, pointData.imageY,
                    canvasWidth, canvasHeight,
                    imageWidth, imageHeight
                );
                
                this.addSpot(
                    canvasCoords.x, canvasCoords.y,
                    pointData.name || ''
                );
            }
        });
        
        this.notify('onChange');
        this.notify('onCountChange', this.spots.length);
    }

    exportToJSON(imageFileName, canvasWidth, canvasHeight, imageWidth, imageHeight) {
        // スポット名がブランクでないスポットのみをフィルタリング
        const validSpots = this.spots.filter(spot => 
            spot.name && spot.name.trim() !== ''
        );
        
        return {
            totalPoints: validSpots.length,
            imageReference: imageFileName,
            imageInfo: {
                width: imageWidth,
                height: imageHeight
            },
            points: validSpots.map((spot, index) => {
                const imageCoords = CoordinateUtils.canvasToImage(
                    spot.x, spot.y,
                    canvasWidth, canvasHeight,
                    imageWidth, imageHeight
                );
                
                return {
                    type: 'spot',
                    index: index + 1,
                    name: spot.name,
                    imageX: imageCoords.x,
                    imageY: imageCoords.y
                };
            }),
            exportedAt: new Date().toISOString()
        };
    }

    generateSpotFilename(imageFileName) {
        const baseFileName = imageFileName || 'spots';
        return `${baseFileName}_spots.json`;
    }
}

// =====================================
// FileHandler
// =====================================
class FileHandler {
    constructor() {
        this.currentImageFileHandle = null;
        this.currentImageFileName = '';
    }

    async selectImage() {
        try {
            if ('showOpenFilePicker' in window) {
                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'PNG Files',
                        accept: {
                            'image/png': ['.png']
                        }
                    }],
                    multiple: false
                });
                
                this.currentImageFileHandle = fileHandle;
                const file = await fileHandle.getFile();
                
                if (!Validators.isPngFile(file)) {
                    throw new Error('PNG画像ファイルを選択してください');
                }
                
                this.currentImageFileName = file.name.replace(/\.png$/i, '');
                const image = await this.loadImageFromFile(file);
                
                return { file, image, fileName: this.currentImageFileName };
            } else {
                throw new Error('File System Access API not supported');
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                throw new Error('ファイル選択がキャンセルされました');
            }
            throw error;
        }
    }

    async loadFromInputFile(file) {
        if (!Validators.isPngFile(file)) {
            throw new Error('PNG画像ファイルを選択してください');
        }
        
        this.currentImageFileName = file.name.replace(/\.png$/i, '');
        const image = await this.loadImageFromFile(file);
        
        return { file, image, fileName: this.currentImageFileName };
    }

    async loadImageFromFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('画像の読み込みに失敗しました'));
                img.src = e.target.result;
            };
            reader.onerror = () => reject(new Error('ファイルの読み込みに失敗しました'));
            reader.readAsDataURL(file);
        });
    }

    async loadJsonFile(file) {
        if (!Validators.isJsonFile(file)) {
            throw new Error('JSONファイルを選択してください');
        }
        
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    resolve(jsonData);
                } catch (error) {
                    reject(new Error('JSONファイルの形式が正しくありません'));
                }
            };
            reader.onerror = () => reject(new Error('ファイルの読み込みに失敗しました'));
            reader.readAsText(file);
        });
    }

    downloadJSON(data, filename) {
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async saveJSONWithUserChoice(data, defaultFilename) {
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        try {
            if ('showSaveFilePicker' in window) {
                let savePickerOptions = {
                    suggestedName: defaultFilename,
                    types: [{
                        description: 'JSON Files',
                        accept: {
                            'application/json': ['.json']
                        }
                    }]
                };
                
                if (this.currentImageFileHandle) {
                    try {
                        const parentDirectoryHandle = await this.currentImageFileHandle.getParent();
                        savePickerOptions.startIn = parentDirectoryHandle;
                    } catch (error) {
                        console.log('同じディレクトリの取得に失敗、デフォルトディレクトリを使用');
                    }
                }
                
                const fileHandle = await window.showSaveFilePicker(savePickerOptions);
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                
                console.log(`JSONファイルが保存されました: ${fileHandle.name}`);
            } else {
                this.downloadJSON(data, defaultFilename);
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('ファイル保存がキャンセルされました');
                return;
            }
            
            console.error('ファイル保存エラー:', error);
            this.downloadJSON(data, defaultFilename);
        }
    }

    getCurrentImageFileName() {
        return this.currentImageFileName;
    }
}

// =====================================
// InputManager
// =====================================
class InputManager {
    constructor(canvas) {
        this.canvas = canvas;
        this.inputElements = [];
        this.spotInputElements = [];
        this.isRouteEditMode = false;
        this.isSpotEditMode = false;
        this.highlightedPointIds = new Set(); // 強調表示するポイントIDのセット
        this.callbacks = {
            onPointIdChange: null,
            onPointRemove: null,
            onSpotNameChange: null,
            onSpotRemove: null
        };
    }

    setCallback(event, callback) {
        this.callbacks[event] = callback;
    }

    notify(event, data) {
        if (this.callbacks[event]) {
            this.callbacks[event](data);
        }
    }

    setEditMode(mode) {
        this.isRouteEditMode = (mode === 'route');
        this.isSpotEditMode = (mode === 'spot');
        
        if (mode !== 'route') {
            // ルート編集モード終了時は強調表示をクリア
            this.highlightedPointIds.clear();
        }
        
        this.updateInputsState();
        this.updateSpotInputsState();
    }

    setRouteEditMode(isRouteEditMode) {
        this.setEditMode(isRouteEditMode ? 'route' : 'point');
    }

    setHighlightedPoints(pointIds) {
        this.highlightedPointIds.clear();
        if (pointIds) {
            pointIds.forEach(id => {
                if (id && id.trim()) {
                    this.highlightedPointIds.add(id);
                }
            });
        }
        this.updateInputsState();
    }

    updateInputsState() {
        this.inputElements.forEach(input => {
            const inputValue = input.value;
            const isHighlighted = this.highlightedPointIds.has(inputValue);
            const container = input._container;
            
            if (this.isSpotEditMode) {
                // スポット編集モード時はポイントID名ポップアップを完全に非表示
                if (container) {
                    container.style.display = 'none';
                }
            } else if (this.isRouteEditMode) {
                // ルート編集モードでは表示し、開始・終了ポイントを強調
                if (container) {
                    container.style.display = 'block';
                }
                input.disabled = true;
                if (isHighlighted) {
                    // 開始・終了ポイントとして指定されている場合は白背景
                    input.style.backgroundColor = 'white';
                    if (container) {
                        container.style.backgroundColor = 'white';
                        container.style.border = '2px solid #007bff';
                    }
                    input.title = '開始または終了ポイントとして指定されています';
                } else {
                    // ルート編集モード時の背景色
                    input.style.backgroundColor = '#e0e0e0';
                    if (container) {
                        container.style.backgroundColor = '#e0e0e0';
                        container.style.border = '2px solid #999';
                    }
                    input.title = 'ルート編集モード中はポイントID名の編集はできません';
                }
            } else {
                // ポイント編集モードでは通常表示
                if (container) {
                    container.style.display = 'block';
                }
                input.disabled = false;
                input.style.backgroundColor = '';
                if (container) {
                    container.style.backgroundColor = '';
                    container.style.border = '';
                }
                input.title = '';
            }
        });
    }

    createInputBox(point, index, shouldFocus = false) {
        
        // ポップアップコンテナを作成
        const container = document.createElement('div');
        container.className = 'point-id-popup';
        container.style.position = 'absolute';
        container.style.zIndex = '1100';

        const input = document.createElement('input');
        input.type = 'text';
        input.maxLength = 4;
        input.className = 'point-id-input';
        input.placeholder = 'ID';
        input.value = point.id || '';
        
        container.appendChild(input);
        
        this.positionInputBox(container, point);
        
        // input時は変換処理を一切行わない
        input.addEventListener('input', (e) => {
            const value = e.target.value;
            
            // 入力中は変換処理なし、そのまま保存（表示更新なし）
            this.notify('onPointIdChange', { index, id: value, skipFormatting: true, skipDisplay: true });
        });
        
        // blur時は単純に値を保存するのみ（フォーマット処理なし）
        input.addEventListener('blur', (e) => {
            const value = e.target.value.trim();
            
            // フォーマット処理なしで更新
            this.notify('onPointIdChange', { index, id: value, skipFormatting: true });
            container.classList.remove('is-editing');
        });
        
        // キーボードイベント（Escapeキーでポイント削除）
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.notify('onPointRemove', { index, point });
            }
        });
        
        // フォーカス時に編集中スタイル
        input.addEventListener('focus', () => {
            container.classList.add('is-editing');
        });
        
        // ポイントインデックスを属性として設定
        input.setAttribute('data-point-index', index);
        
        document.body.appendChild(container);
        this.inputElements.push(input);
        // 入力からコンテナへ参照
        input._container = container;

        // 編集モードの状態を適用
        if (this.isSpotEditMode) {
            // スポット編集モード時はポイントID名ポップアップを完全に非表示
            container.style.display = 'none';
        } else if (this.isRouteEditMode) {
            // ルート編集モードでは表示し、開始・終了ポイントを強調
            const isHighlighted = this.highlightedPointIds.has(point.id);
            input.disabled = true;
            if (isHighlighted) {
                // 開始・終了ポイントとして指定されている場合は白背景
                input.style.backgroundColor = 'white';
                container.style.backgroundColor = 'white';
                container.style.border = '2px solid #007bff';
                input.title = '開始または終了ポイントとして指定されています';
            } else {
                // ルート編集モード時の背景色
                input.style.backgroundColor = '#e0e0e0';
                container.style.backgroundColor = '#e0e0e0';
                container.style.border = '2px solid #999';
                input.title = 'ルート編集モード中はポイントID名の編集はできません';
            }
        }

        if (shouldFocus) {
            setTimeout(() => {
                input.focus();
                // カーソルを末尾に設定
                input.setSelectionRange(input.value.length, input.value.length);
            }, 0);
        }
    }

    positionInputBox(container, point) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = rect.width / this.canvas.width;
        const scaleY = rect.height / this.canvas.height;
        
        const inputX = this.findOptimalInputPosition(point.x, point.y, scaleX, rect.left);
        const inputY = point.y * scaleY + rect.top - 15;
        
        container.style.left = inputX + 'px';
        container.style.top = inputY + 'px';
    }

    findOptimalInputPosition(pointX, pointY, scaleX, canvasLeft) {
        const inputWidth = 50;
        const margin = 10;
        const scaledPointX = pointX * scaleX + canvasLeft;
        
        const rightPos = scaledPointX + margin;
        const leftPos = scaledPointX - inputWidth - margin;
        
        if (rightPos + inputWidth < window.innerWidth - 20) {
            return rightPos;
        } else {
            return Math.max(leftPos, canvasLeft + 5);
        }
    }

    updatePointIdDisplay(pointIndex, newId) {
        const input = this.inputElements.find((element) => {
            // 入力要素に紐づくポイントのインデックスを確認
            return element.getAttribute('data-point-index') == pointIndex;
        });
        if (input && input.value !== newId) {
            input.value = newId;
        }
    }

    redrawInputBoxes(points) {
        this.clearInputBoxes();
        
        setTimeout(() => {
            points.forEach((point, index) => {
                this.createInputBox(point, index);
                const input = this.inputElements[this.inputElements.length - 1];
                if (input) {
                    input.value = point.id || '';
                    input.setAttribute('data-point-index', index);
                }
            });
        }, 10);
    }

    createSpotInputBox(spot, index, shouldFocus = false) {
        // ポップアップコンテナを作成
        const container = document.createElement('div');
        container.className = 'spot-name-popup';
        container.style.position = 'absolute';
        container.style.zIndex = '1100';

        const input = document.createElement('input');
        input.type = 'text';
        input.maxLength = 10;  // 10文字程度に設定
        input.className = 'spot-name-input';
        input.placeholder = 'スポット名';
        input.value = spot.name || '';
        
        container.appendChild(input);
        
        this.positionSpotInputBox(container, spot);
        
        // input時は変換処理を一切行わない
        input.addEventListener('input', (e) => {
            const value = e.target.value;
            // 入力中は変換処理なし、そのまま保存（表示更新なし）
            this.notify('onSpotNameChange', { index, name: value, skipDisplay: true });
        });
        
        // blur時は単純に値を保存するのみ
        input.addEventListener('blur', (e) => {
            const value = e.target.value.trim();
            this.notify('onSpotNameChange', { index, name: value });
            container.classList.remove('is-editing');
        });
        
        // キーボードイベント（Escapeキーでスポット削除）
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.notify('onSpotRemove', { index, spot });
            }
        });
        
        // フォーカス時に編集中スタイル
        input.addEventListener('focus', () => {
            container.classList.add('is-editing');
        });
        
        // スポットインデックスを属性として設定
        input.setAttribute('data-spot-index', index);
        
        document.body.appendChild(container);
        this.spotInputElements.push(input);
        // 入力からコンテナへ参照
        input._container = container;

        if (shouldFocus) {
            setTimeout(() => {
                input.focus();
                // カーソルを末尾に設定
                input.setSelectionRange(input.value.length, input.value.length);
            }, 0);
        }
    }

    positionSpotInputBox(container, spot) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = rect.width / this.canvas.width;
        const scaleY = rect.height / this.canvas.height;
        
        const inputX = this.findOptimalInputPosition(spot.x, spot.y, scaleX, rect.left);
        const inputY = spot.y * scaleY + rect.top - 15;
        
        container.style.left = inputX + 'px';
        container.style.top = inputY + 'px';
    }

    updateSpotInputsState() {
        this.spotInputElements.forEach(input => {
            const container = input._container;
            
            if (!this.isSpotEditMode) {
                // スポット編集モード以外では非表示
                if (container) {
                    container.style.display = 'none';
                }
            } else {
                // スポット編集モードでは表示
                if (container) {
                    container.style.display = 'block';
                }
            }
        });
    }

    updateSpotNameDisplay(spotIndex, newName) {
        const input = this.spotInputElements.find((element) => {
            // 入力要素に紐づくスポットのインデックスを確認
            return element.getAttribute('data-spot-index') == spotIndex;
        });
        if (input && input.value !== newName) {
            input.value = newName;
        }
    }

    redrawSpotInputBoxes(spots) {
        this.clearSpotInputBoxes();
        
        if (this.isSpotEditMode) {
            setTimeout(() => {
                spots.forEach((spot, index) => {
                    this.createSpotInputBox(spot, index);
                    const input = this.spotInputElements[this.spotInputElements.length - 1];
                    if (input) {
                        input.value = spot.name || '';
                        input.setAttribute('data-spot-index', index);
                    }
                });
            }, 10);
        }
    }

    clearInputBoxes() {
        this.inputElements.forEach(input => {
            const container = input && input._container;
            if (container && container.parentNode) {
                container.parentNode.removeChild(container);
            } else if (input && input.parentNode) {
                // 後方互換（コンテナ未設定の場合）
                input.parentNode.removeChild(input);
            }
        });
        this.inputElements = [];
    }

    clearSpotInputBoxes() {
        this.spotInputElements.forEach(input => {
            const container = input && input._container;
            if (container && container.parentNode) {
                container.parentNode.removeChild(container);
            } else if (input && input.parentNode) {
                // 後方互換（コンテナ未設定の場合）
                input.parentNode.removeChild(input);
            }
        });
        this.spotInputElements = [];
    }

    clearAllInputBoxes() {
        this.clearInputBoxes();
        this.clearSpotInputBoxes();
    }
}

// =====================================
// LayoutManager
// =====================================
class LayoutManager {
    constructor() {
        this.currentLayout = 'sidebar';
        this.currentEditingMode = 'point';
        this.callbacks = {
            onLayoutChange: null,
            onModeChange: null
        };
        
        this.initializeEventListeners();
        this.updateDisplay();
    }

    setCallback(event, callback) {
        this.callbacks[event] = callback;
    }

    notify(event, data) {
        if (this.callbacks[event]) {
            this.callbacks[event](data);
        }
    }

    initializeEventListeners() {
        const layoutRadios = document.querySelectorAll('input[name="layout"]');
        layoutRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.setLayout(e.target.value);
                }
            });
        });
        
        const editingModeRadios = document.querySelectorAll('input[name="editingMode"]');
        editingModeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.setEditingMode(e.target.value);
                }
            });
        });
    }

    setLayout(layout) {
        this.currentLayout = layout;
        this.updateLayoutDisplay();
        this.notify('onLayoutChange', layout);
    }

    setEditingMode(mode) {
        this.currentEditingMode = mode;
        this.updateEditingModeDisplay();
        this.notify('onModeChange', mode);
    }

    getCurrentLayout() {
        return this.currentLayout;
    }

    getCurrentEditingMode() {
        return this.currentEditingMode;
    }

    updateLayoutDisplay() {
        const mainContent = document.querySelector('.main-content');
        mainContent.setAttribute('data-layout', this.currentLayout);
        
        const radio = document.querySelector(`input[name="layout"][value="${this.currentLayout}"]`);
        if (radio) {
            radio.checked = true;
        }
    }

    updateEditingModeDisplay() {
        const pointEditor = document.getElementById('pointEditor');
        const routeEditor = document.getElementById('routeEditor');
        const spotEditor = document.getElementById('spotEditor');
        
        // 全パネルを一旦非表示
        pointEditor.style.display = 'none';
        routeEditor.style.display = 'none';
        spotEditor.style.display = 'none';
        
        // 選択されたモードのパネルのみ表示
        if (this.currentEditingMode === 'point') {
            pointEditor.style.display = 'flex';
        } else if (this.currentEditingMode === 'route') {
            routeEditor.style.display = 'block';
        } else if (this.currentEditingMode === 'spot') {
            spotEditor.style.display = 'flex';
        }
        
        const radio = document.querySelector(`input[name="editingMode"][value="${this.currentEditingMode}"]`);
        if (radio) {
            radio.checked = true;
        }
    }

    updateDisplay() {
        this.updateLayoutDisplay();
        this.updateEditingModeDisplay();
    }

    setDefaultPointMode() {
        const radio = document.querySelector('input[name="editingMode"][value="point"]');
        if (radio) {
            radio.checked = true;
        }
        this.setEditingMode('point');
    }
}

// =====================================
// PointMarkerApp
// =====================================
class PointMarkerApp {
    constructor() {
        // DOM要素の初期化
        this.canvas = document.getElementById('mapCanvas');
        
        // コアコンポーネントの初期化
        this.canvasRenderer = new CanvasRenderer(this.canvas);
        this.pointManager = new PointManager();
        this.routeManager = new RouteManager();
        this.spotManager = new SpotManager();
        this.fileHandler = new FileHandler();
        this.inputManager = new InputManager(this.canvas);
        this.layoutManager = new LayoutManager();
        
        // 現在の画像情報
        this.currentImage = null;
        
        // ドラッグ状態管理
        this.isDragging = false;
        this.draggedPointIndex = -1;
        this.draggedSpotIndex = -1;
        this.dragOffsetX = 0;
        this.dragOffsetY = 0;
        this.isHoveringPoint = false;
        
        this.initializeCallbacks();
        this.initializeEventListeners();
        this.enableBasicControls();
    }

    initializeCallbacks() {
        // ポイント管理のコールバック
        this.pointManager.setCallback('onChange', (points, skipRedrawInput = false) => {
            this.redrawCanvas();
            if (!skipRedrawInput) {
                this.inputManager.redrawInputBoxes(points);
            }
        });
        
        this.pointManager.setCallback('onCountChange', (count) => {
            document.getElementById('pointCount').textContent = count;
        });

        // ルート管理のコールバック
        this.routeManager.setCallback('onChange', () => {
            this.redrawCanvas();
        });
        
        this.routeManager.setCallback('onCountChange', (count) => {
            document.getElementById('waypointCount').textContent = count;
        });
        
        this.routeManager.setCallback('onStartEndChange', (data) => {
            document.getElementById('startPointInput').value = data.start;
            document.getElementById('endPointInput').value = data.end;
            
            // InputManagerに開始・終了ポイントの強調表示を更新
            const highlightIds = [];
            if (data.start && data.start.trim()) highlightIds.push(data.start);
            if (data.end && data.end.trim()) highlightIds.push(data.end);
            this.inputManager.setHighlightedPoints(highlightIds);
            
            this.redrawCanvas();
        });

        // スポット管理のコールバック
        this.spotManager.setCallback('onChange', (spots, skipRedrawInput = false) => {
            this.redrawCanvas();
            if (!skipRedrawInput) {
                this.inputManager.redrawSpotInputBoxes(spots || this.spotManager.getSpots());
            }
        });
        
        this.spotManager.setCallback('onCountChange', (count) => {
            document.getElementById('spotCount').textContent = count;
        });

        // キャンバスのみの再描画用コールバック（入力ボックス再生成なし）
        this.spotManager.setCallback('onCanvasRedraw', () => {
            this.redrawCanvas();
        });

        // 入力管理のコールバック
        this.inputManager.setCallback('onPointIdChange', (data) => {
            this.pointManager.updatePointId(data.index, data.id, data.skipFormatting, true);
            // 入力中の場合は表示更新をスキップ（入力ボックスの値はそのまま維持）
            if (!data.skipDisplay) {
                this.inputManager.updatePointIdDisplay(data.index, data.id);
            }
        });
        
        this.inputManager.setCallback('onPointRemove', (data) => {
            if (this.layoutManager.getCurrentEditingMode() === 'point') {
                this.pointManager.removePoint(data.index);
            }
        });
        
        // スポット名変更のコールバック
        this.inputManager.setCallback('onSpotNameChange', (data) => {
            // 入力中はスポット入力ボックス再生成をスキップ
            this.spotManager.updateSpotName(data.index, data.name, !!data.skipDisplay);
            // 入力中の場合は表示更新をスキップ（入力ボックスの値はそのまま維持）
            if (!data.skipDisplay) {
                this.inputManager.updateSpotNameDisplay(data.index, data.name);
            }
        });
        
        this.inputManager.setCallback('onSpotRemove', (data) => {
            if (this.layoutManager.getCurrentEditingMode() === 'spot') {
                this.spotManager.removeSpot(data.index);
            }
        });

        // レイアウト管理のコールバック
        this.layoutManager.setCallback('onLayoutChange', (layout) => {
            if (this.currentImage) {
                setTimeout(() => this.handleWindowResize(), 300);
            }
        });
        
        this.layoutManager.setCallback('onModeChange', (mode) => {
            this.inputManager.setEditMode(mode);
            if (mode === 'route') {
                // ルート編集モードに切り替えた時、既存の開始・終了ポイントを強調表示
                const startEndPoints = this.routeManager.getStartEndPoints();
                const highlightIds = [];
                if (startEndPoints.start && startEndPoints.start.trim()) highlightIds.push(startEndPoints.start);
                if (startEndPoints.end && startEndPoints.end.trim()) highlightIds.push(startEndPoints.end);
                this.inputManager.setHighlightedPoints(highlightIds);
            } else if (mode === 'spot') {
                // スポット編集モードに切り替えた時、スポット入力ボックスを表示
                this.inputManager.redrawSpotInputBoxes(this.spotManager.getSpots());
            }
            this.redrawCanvas();
        });
    }

    initializeEventListeners() {
        // 画像選択
        const imageInputLabel = document.querySelector('label[for="imageInput"]');
        imageInputLabel.addEventListener('click', async (e) => {
            e.preventDefault();
            await this.handleImageSelection();
        });

        // キャンバスクリック
        this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        
        // マウス移動（ホバー検出・ドラッグ処理）
        this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
        this.canvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleCanvasMouseUp(e));
        

        // ポイント編集コントロール
        document.getElementById('clearBtn').addEventListener('click', (e) => {
            e.preventDefault();
            this.clearPoints();
        });
        
        document.getElementById('formatBtn').addEventListener('click', (e) => {
            e.preventDefault();
            this.formatAllPointIds();
        });
        
        document.getElementById('exportBtn').addEventListener('click', async (e) => {
            e.preventDefault();
            await this.exportPoints();
        });
        
        document.getElementById('jsonInput').addEventListener('change', (e) => this.handlePointJSONLoad(e));

        // ルート編集コントロール
        document.getElementById('clearRouteBtn').addEventListener('click', (e) => {
            e.preventDefault();
            this.clearRoute();
        });
        
        document.getElementById('exportRouteBtn').addEventListener('click', async (e) => {
            e.preventDefault();
            await this.exportRoute();
        });
        
        document.getElementById('routeJsonInput').addEventListener('change', (e) => this.handleRouteJSONLoad(e));

        // スポット編集コントロール
        document.getElementById('clearSpotBtn').addEventListener('click', (e) => {
            e.preventDefault();
            this.clearSpots();
        });
        
        document.getElementById('exportSpotBtn').addEventListener('click', async (e) => {
            e.preventDefault();
            await this.exportSpots();
        });
        
        document.getElementById('spotJsonInput').addEventListener('change', (e) => this.handleSpotJSONLoad(e));

        // 開始・終了ポイント入力
        const startPointInput = document.getElementById('startPointInput');
        const endPointInput = document.getElementById('endPointInput');
        
        // input時は変換処理を一切行わない（フォーマット処理もしない）
        startPointInput.addEventListener('input', (e) => {
            const value = e.target.value;
            // 入力中は変換処理なし、フォーマット処理をスキップして設定
            this.routeManager.setStartPoint(value, true);
        });
        
        endPointInput.addEventListener('input', (e) => {
            const value = e.target.value;
            // 入力中は変換処理なし、フォーマット処理をスキップして設定
            this.routeManager.setEndPoint(value, true);
        });
        
        // blur時にX-nn形式のフォーマット処理を実行
        startPointInput.addEventListener('blur', (e) => {
            this.routeManager.setStartPoint(e.target.value);
            const newValue = this.routeManager.getStartEndPoints().start;
            e.target.value = newValue;
            
            // 開始・終了ポイント両方の検証フィードバック
            this.updateBothRoutePointsValidation();
        });
        
        endPointInput.addEventListener('blur', (e) => {
            this.routeManager.setEndPoint(e.target.value);
            const newValue = this.routeManager.getStartEndPoints().end;
            e.target.value = newValue;
            
            // 開始・終了ポイント両方の検証フィードバック
            this.updateBothRoutePointsValidation();
        });

        // ウィンドウリサイズ
        window.addEventListener('resize', () => {
            if (this.currentImage) {
                setTimeout(() => this.handleWindowResize(), 100);
            }
        });
    }

    enableBasicControls() {
        // 初期状態では画像読み込み前なので無効化
    }

    enableImageControls() {
        document.getElementById('clearBtn').disabled = false;
        document.getElementById('formatBtn').disabled = false;
        document.getElementById('exportBtn').disabled = false;
    }

    async handleImageSelection() {
        try {
            const result = await this.fileHandler.selectImage();
            await this.processLoadedImage(result.image, result.fileName);
        } catch (error) {
            if (error.message !== 'ファイル選択がキャンセルされました') {
                console.error('画像選択エラー:', error);
                alert('画像選択中にエラーが発生しました: ' + error.message);
            }
        }
    }

    async processLoadedImage(image, fileName) {
        this.currentImage = image;
        this.canvasRenderer.setImage(image);
        this.canvasRenderer.setupCanvas(this.layoutManager.getCurrentLayout());
        this.canvasRenderer.drawImage();
        this.enableImageControls();
        this.layoutManager.setDefaultPointMode();
    }

    findPointAtMouse(mouseX, mouseY) {
        const points = this.pointManager.getPoints();
        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            const dx = mouseX - point.x;
            const dy = mouseY - point.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            // ポイントの半径（デフォルトは4）よりも少し大きめの範囲で検出
            if (distance <= 8) {
                return i;
            }
        }
        return -1;
    }

    findSpotAtMouse(mouseX, mouseY) {
        return this.spotManager.findSpotAt(mouseX, mouseY, 10); // 星形は少し大きいので許容値を大きく
    }


    handleCanvasMouseMove(event) {
        if (!this.currentImage) return;
        
        const coords = CoordinateUtils.mouseToCanvas(event, this.canvas);
        const pointIndex = this.findPointAtMouse(coords.x, coords.y);
        const spotIndex = this.findSpotAtMouse(coords.x, coords.y);
        
        if (this.isDragging && this.draggedPointIndex !== -1) {
            // ポイントドラッグ中の場合、ポイント位置を更新
            const newX = coords.x - this.dragOffsetX;
            const newY = coords.y - this.dragOffsetY;
            
            const points = this.pointManager.getPoints();
            if (this.draggedPointIndex < points.length) {
                points[this.draggedPointIndex].x = Math.round(newX);
                points[this.draggedPointIndex].y = Math.round(newY);
                this.redrawCanvas();
            }
        } else if (this.isDragging && this.draggedSpotIndex !== -1) {
            // スポットドラッグ中の場合、スポット位置を更新
            const newX = coords.x - this.dragOffsetX;
            const newY = coords.y - this.dragOffsetY;
            
            this.spotManager.updateSpotPosition(this.draggedSpotIndex, newX, newY);
        } else if (pointIndex !== -1 || spotIndex !== -1) {
            // ポイントまたはスポット上にマウスがある場合、十字カーソルを維持
            if (!this.isHoveringPoint) {
                this.canvas.style.cursor = 'crosshair';
                this.isHoveringPoint = true;
            }
        } else {
            // ポイント・スポット上にない場合、十字カーソルを維持
            if (this.isHoveringPoint) {
                this.canvas.style.cursor = 'crosshair';
                this.isHoveringPoint = false;
            }
        }
    }

    handleCanvasMouseDown(event) {
        if (!this.currentImage) return;
        
        const coords = CoordinateUtils.mouseToCanvas(event, this.canvas);
        const pointIndex = this.findPointAtMouse(coords.x, coords.y);
        const spotIndex = this.findSpotAtMouse(coords.x, coords.y);
        const mode = this.layoutManager.getCurrentEditingMode();
        
        if (pointIndex !== -1 && mode === 'point') {
            // ポイント上でクリック、ドラッグ開始
            this.isDragging = true;
            this.draggedPointIndex = pointIndex;
            
            const point = this.pointManager.getPoints()[pointIndex];
            this.dragOffsetX = coords.x - point.x;
            this.dragOffsetY = coords.y - point.y;
            
            event.preventDefault();
        } else if (spotIndex !== -1 && mode === 'spot') {
            // スポット上でクリック、ドラッグ開始
            this.isDragging = true;
            this.draggedSpotIndex = spotIndex;
            
            const spot = this.spotManager.getSpots()[spotIndex];
            this.dragOffsetX = coords.x - spot.x;
            this.dragOffsetY = coords.y - spot.y;
            
            event.preventDefault();
        }
    }

    handleCanvasMouseUp(event) {
        if (this.isDragging) {
            this.isDragging = false;
            
            // ポイント移動後に入力ボックスを再描画
            if (this.draggedPointIndex !== -1) {
                this.inputManager.redrawInputBoxes(this.pointManager.getPoints());
                // ポイントデータ変更を通知
                this.pointManager.notify('onChange', this.pointManager.getPoints());
            }
            
            this.draggedPointIndex = -1;
            this.draggedSpotIndex = -1;
            this.dragOffsetX = 0;
            this.dragOffsetY = 0;
        }
    }

    handleCanvasClick(event) {
        if (!this.currentImage) return;
        
        // ドラッグ中のクリックは無視
        if (this.isDragging) {
            return;
        }
        
        const coords = CoordinateUtils.mouseToCanvas(event, this.canvas);
        const mode = this.layoutManager.getCurrentEditingMode();
        
        // ポイント上でのクリックはポイント追加しないが、入力フィールドにフォーカス
        const pointIndex = this.findPointAtMouse(coords.x, coords.y);
        const spotIndex = this.findSpotAtMouse(coords.x, coords.y);
        
        if (pointIndex !== -1) {
            // 既存ポイントクリック時は対応する入力フィールドにフォーカス
            if (mode === 'point') {
                this.focusInputForPoint(pointIndex);
            }
            return;
        }
        
        if (spotIndex !== -1 && mode === 'spot') {
            // スポット上でのクリックは対応するスポット名入力フィールドにフォーカス
            this.focusInputForSpot(spotIndex);
            return;
        }
        
        if (mode === 'route') {
            this.routeManager.addRoutePoint(coords.x, coords.y);
        } else if (mode === 'point') {
            // ポイント編集モードでのみポイント追加を許可
            this.pointManager.removeTrailingEmptyUserPoints();
            const point = this.pointManager.addPoint(coords.x, coords.y);
            // onChange -> redrawInputBoxesで生成されるため、ここでは生成しない
            // 新規作成された最後のポイントの入力へフォーカス
            const newIndex = this.pointManager.getPoints().length - 1;
            setTimeout(() => this.focusInputForPoint(newIndex), 30);
        } else if (mode === 'spot') {
            // スポット編集モードでスポット追加
            this.spotManager.removeTrailingEmptySpots();
            const spot = this.spotManager.addSpot(coords.x, coords.y);
            // 新規作成されたスポットの入力へフォーカス
            const newIndex = this.spotManager.getSpots().length - 1;
            setTimeout(() => this.focusInputForSpot(newIndex), 30);
        }
    }

    redrawCanvas() {
        const mode = this.layoutManager.getCurrentEditingMode();
        const routePoints = this.routeManager.getStartEndPoints();
        
        this.canvasRenderer.redraw(
            this.pointManager.getPoints(),
            this.routeManager.getRoutePoints(),
            this.spotManager.getSpots(),
            {
                showRouteMode: mode === 'route',
                startPointId: routePoints.start,
                endPointId: routePoints.end
            }
        );
    }

    clearPoints() {
        this.pointManager.clearPoints();
        this.inputManager.clearInputBoxes();
    }

    clearRoute() {
        this.routeManager.clearRoute();
    }

    clearSpots() {
        this.spotManager.clearSpots();
        this.inputManager.clearSpotInputBoxes();
    }

    checkDuplicatePointIds(points) {
        const idCount = {};
        const duplicates = [];
        
        // 空でないIDのみをチェック対象にする
        points.forEach(point => {
            if (point.id && point.id.trim() !== '') {
                const id = point.id.trim();
                idCount[id] = (idCount[id] || 0) + 1;
                if (idCount[id] === 2) {
                    duplicates.push(id);
                }
            }
        });
        
        const isValid = duplicates.length === 0;
        let message = '';
        
        if (!isValid) {
            message = `重複するポイントID名が見つかりました: ${duplicates.join(', ')}\n` +
                     'ポイントID名を修正してから再度エクスポートしてください。';
        }
        
        return { isValid, duplicates, message };
    }

    async exportPoints() {
        const points = this.pointManager.getPoints();
        if (points.length === 0) {
            alert('ポイントが選択されていません');
            return;
        }

        // ポイントID名の重複チェック
        const duplicateCheck = this.checkDuplicatePointIds(points);
        if (!duplicateCheck.isValid) {
            alert(duplicateCheck.message);
            return;
        }

        try {
            const data = this.pointManager.exportToJSON(
                this.fileHandler.getCurrentImageFileName() + '.png',
                this.canvas.width, this.canvas.height,
                this.currentImage.width, this.currentImage.height
            );
            
            const filename = `${this.fileHandler.getCurrentImageFileName()}_points.json`;
            await this.fileHandler.saveJSONWithUserChoice(data, filename);
        } catch (error) {
            console.error('エクスポートエラー:', error);
            alert('エクスポート中にエラーが発生しました');
        }
    }

    formatAllPointIds() {
        this.pointManager.formatAllPointIds();
        this.inputManager.redrawInputBoxes(this.pointManager.getPoints());
        this.redrawCanvas();
    }

    async exportRoute() {
        const routePoints = this.routeManager.getRoutePoints();
        if (routePoints.length === 0) {
            alert('ルートポイントが選択されていません');
            return;
        }

        const validation = this.routeManager.validateStartEndPoints(
            this.pointManager.getRegisteredIds()
        );
        
        if (!validation.isValid) {
            alert(validation.message);
            return;
        }

        try {
            const data = this.routeManager.exportToJSON(
                this.fileHandler.getCurrentImageFileName() + '.png',
                this.canvas.width, this.canvas.height,
                this.currentImage.width, this.currentImage.height
            );
            
            const filename = this.routeManager.generateRouteFilename(
                this.fileHandler.getCurrentImageFileName()
            );
            
            await this.fileHandler.saveJSONWithUserChoice(data, filename);
        } catch (error) {
            console.error('エクスポートエラー:', error);
            alert('エクスポート中にエラーが発生しました');
        }
    }

    async handlePointJSONLoad(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!this.currentImage) {
            alert('先に画像を読み込んでください');
            return;
        }

        try {
            const data = await this.fileHandler.loadJsonFile(file);
            this.pointManager.loadFromJSON(
                data,
                this.canvas.width, this.canvas.height,
                this.currentImage.width, this.currentImage.height
            );
        } catch (error) {
            console.error('JSON読み込みエラー:', error);
            alert('JSON読み込み中にエラーが発生しました: ' + error.message);
        } finally {
            event.target.value = '';
        }
    }

    async handleRouteJSONLoad(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!this.currentImage) {
            alert('先に画像を読み込んでください');
            return;
        }

        try {
            const data = await this.fileHandler.loadJsonFile(file);
            this.routeManager.loadFromJSON(
                data,
                this.canvas.width, this.canvas.height,
                this.currentImage.width, this.currentImage.height
            );
        } catch (error) {
            console.error('ルートJSON読み込みエラー:', error);
            alert('ルートJSON読み込み中にエラーが発生しました: ' + error.message);
        } finally {
            event.target.value = '';
        }
    }

    updateInputValidationFeedback(inputElement, value) {
        // Validatorsクラスをインポートしていないため、ここで直接チェック
        const isValidFormat = this.isValidPointIdFormat(value);
        
        if (!isValidFormat && value.trim() !== '') {
            // 無効な形式の場合は薄いピンクの背景色とツールチップを設定
            inputElement.style.backgroundColor = '#ffe4e4';
            inputElement.style.borderColor = '#ff6b6b';
            inputElement.title = 'X-nn形式で入力してください（例：A-01, J-12）';
        } else {
            // 有効な形式の場合は通常の表示に戻す
            inputElement.style.backgroundColor = '';
            inputElement.style.borderColor = '';
            inputElement.title = '';
        }
    }

    updateRoutePointValidationFeedback(inputElement, value) {
        // 空の場合は正常（クリア）
        if (!value || value.trim() === '') {
            inputElement.style.backgroundColor = '';
            inputElement.style.borderColor = '';
            inputElement.title = '';
            return;
        }

        // 形式チェック
        const isValidFormat = this.isValidPointIdFormat(value);
        if (!isValidFormat) {
            inputElement.style.backgroundColor = '#ffe4e4';
            inputElement.style.borderColor = '#ff6b6b';
            inputElement.title = 'X-nn形式で入力してください（例：A-01, J-12）';
            return;
        }

        // 既存ポイントIDの存在チェック
        const existingPointIds = this.pointManager.getRegisteredIds();
        const pointExists = existingPointIds.includes(value);
        
        if (!pointExists) {
            // 存在しないポイントIDの場合は赤枠表示
            inputElement.style.backgroundColor = '';
            inputElement.style.borderColor = '#ff0000';
            inputElement.title = `ポイントID「${value}」は存在しません。先にポイント編集でポイントを作成してください。`;
        } else {
            // 存在するポイントIDの場合は通常表示
            inputElement.style.backgroundColor = '';
            inputElement.style.borderColor = '';
            inputElement.title = '';
        }
    }

    updateBothRoutePointsValidation() {
        const startPointInput = document.getElementById('startPointInput');
        const endPointInput = document.getElementById('endPointInput');
        const routePoints = this.routeManager.getStartEndPoints();
        const startValue = routePoints.start;
        const endValue = routePoints.end;

        // 個別の検証を実行
        this.updateRoutePointValidationFeedback(startPointInput, startValue);
        this.updateRoutePointValidationFeedback(endPointInput, endValue);

        // 重複チェック（両方が空でない場合のみ）
        if (startValue && endValue && startValue.trim() !== '' && endValue.trim() !== '') {
            if (startValue === endValue) {
                // 開始と終了が同じ場合、両方を赤枠表示
                startPointInput.style.borderColor = '#ff0000';
                endPointInput.style.borderColor = '#ff0000';
                startPointInput.title = '開始ポイントと終了ポイントは異なるポイントIDを指定してください。';
                endPointInput.title = '開始ポイントと終了ポイントは異なるポイントIDを指定してください。';
            }
        }
    }

    isValidPointIdFormat(value) {
        if (!value || value.trim() === '') {
            return true;
        }
        
        const validPattern = /^[A-Z]-\d{2}$/;
        return validPattern.test(value);
    }

    focusInputForPoint(pointIndex) {
        const inputElement = document.querySelector(`input[data-point-index="${pointIndex}"]`);
        if (inputElement) {
            inputElement.focus();
            // カーソルを末尾に設定
            inputElement.setSelectionRange(inputElement.value.length, inputElement.value.length);
        }
    }

    focusInputForSpot(spotIndex) {
        const inputElement = document.querySelector(`input[data-spot-index="${spotIndex}"]`);
        if (inputElement) {
            inputElement.focus();
            // カーソルを末尾に設定
            inputElement.setSelectionRange(inputElement.value.length, inputElement.value.length);
        }
    }

    async exportSpots() {
        const spots = this.spotManager.getSpots();
        if (spots.length === 0) {
            alert('スポットが選択されていません');
            return;
        }

        try {
            const data = this.spotManager.exportToJSON(
                this.fileHandler.getCurrentImageFileName() + '.png',
                this.canvas.width, this.canvas.height,
                this.currentImage.width, this.currentImage.height
            );
            
            const filename = this.spotManager.generateSpotFilename(
                this.fileHandler.getCurrentImageFileName()
            );
            await this.fileHandler.saveJSONWithUserChoice(data, filename);
        } catch (error) {
            console.error('スポットエクスポートエラー:', error);
            alert('スポットエクスポート中にエラーが発生しました');
        }
    }

    async handleSpotJSONLoad(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!this.currentImage) {
            alert('先に画像を読み込んでください');
            return;
        }

        try {
            const data = await this.fileHandler.loadJsonFile(file);
            this.spotManager.loadFromJSON(
                data,
                this.canvas.width, this.canvas.height,
                this.currentImage.width, this.currentImage.height
            );
        } catch (error) {
            console.error('スポットJSON読み込みエラー:', error);
            alert('スポットJSON読み込み中にエラーが発生しました: ' + error.message);
        } finally {
            event.target.value = '';
        }
    }

    handleWindowResize() {
        if (!this.currentImage) return;
        
        const oldWidth = this.canvas.width;
        const oldHeight = this.canvas.height;
        
        this.canvasRenderer.setupCanvas(this.layoutManager.getCurrentLayout());
        
        const newWidth = this.canvas.width;
        const newHeight = this.canvas.height;
        
        if (oldWidth !== newWidth || oldHeight !== newHeight) {
            const scaleX = newWidth / oldWidth;
            const scaleY = newHeight / oldHeight;
            
            // ポイント座標のスケーリング
            this.pointManager.getPoints().forEach(point => {
                point.x = Math.round(point.x * scaleX);
                point.y = Math.round(point.y * scaleY);
            });
            
            // ルートポイント座標のスケーリング
            this.routeManager.getRoutePoints().forEach(point => {
                point.x = Math.round(point.x * scaleX);
                point.y = Math.round(point.y * scaleY);
            });
            
            // スポット座標のスケーリング
            this.spotManager.getSpots().forEach(spot => {
                spot.x = Math.round(spot.x * scaleX);
                spot.y = Math.round(spot.y * scaleY);
            });
        }
        
        this.redrawCanvas();
    }
}

// DOM読み込み完了後にアプリケーションを初期化
document.addEventListener('DOMContentLoaded', () => {
    new PointMarkerApp();
});
    </script>
</body>
</html>